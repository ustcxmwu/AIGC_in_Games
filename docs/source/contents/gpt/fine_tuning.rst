.. _Fine Tuning Technology:

大模型微调技术
================================================================================

fine-tuning 技术
--------------------------------------------------------------------------------

Fine-tuning是一种在自然语言处理（NLP）中使用的技术，用于将预训练的语言模型适应于特定任务或领域。Fine-tuning的基本思想是采用已经在大量文本上进行训练的预训练语言模型，然后在小规模的任务特定文本上继续训练它。

经典的fine-tuning方法包括将预训练模型与少量特定任务数据一起继续训练。在这个过程中，预训练模型的权重被更新，以更好地适应任务。所需的fine-tuning量取决于预训练语料库和任务特定语料库之间的相似性。如果两者相似，可能只需要少量的fine-tuning。如果两者不相似，则可能需要更多的fine-tuning。

在NLP中，fine-tuning最著名的例子之一是由OpenAI开发的OpenAI GPT（生成式预训练变压器）模型。GPT模型在大量文本上进行了预训练，然后在各种任务上进行了微调，例如语言建模，问答和摘要。经过微调的模型在这些任务上取得了最先进的性能。


parameter-efficient fine-tuning 技术
--------------------------------------------------------------------------------

参数高效的fine-tuning，简称PEFT，旨在在尽可能减少所需的参数和计算资源的情况下，实现对预训练语言模型的有效微调。它是自然语言处理（NLP）中一组用于将预训练语言模型适应特定任务的方法，其所需参数和计算资源比传统的fine-tuning方法更少。

换个角度说，parameter-efficient fine-tuning技术在通过仅训练一小组参数来解决传统微调技术需要大量资源的问题，这些参数可能是现有模型参数的子集或新添加的一组参数。这些方法在参数效率、内存效率、训练速度、模型的最终质量和附加推理成本（如果有的话）方面存在差异。

这些技术对于研究人员和开发人员非常重要，因为他们可能无法使用强大的硬件或需要在低资源设备上进行模型微调。

其中一种参数高效的fine-tuning技术称为蒸馏(distillation)，它由Hinton等人于2015年引入。该方法涉及训练一个较小的模型来模仿一个较大的预训练模型的行为。预训练模型生成“教师”预测结果，然后用于训练较小的“学生”模型。通过这样做，学生模型可以从较大模型的知识中学习，而无需存储所有参数。

另一种技术称为适配器训练(adapter training)，它由Houlsby等人于2019年引入。适配器是添加到预训练模型中的小型神经网络，用于特定任务的微调。这些适配器只占原始模型大小的一小部分，这使得训练更快，内存需求更低。适配器可以针对多种任务进行训练，然后插入到预训练模型中以执行新任务。

第三种技术称为渐进收缩(progressive shrinking)，它由Kaplan等人于2020年引入。这种技术涉及在fine-tuning期间逐渐减小预训练模型的大小。从一个大模型开始，逐渐减少参数的数量，直到达到所需的性能。这种方法可以产生比从头开始训练的模型性能更好的小型模型。

prompt-tuning 技术
--------------------------------------------------------------------------------

prompt-tuning是一种更近期的精调预训练语言模型的方法，重点是调整输入提示（input prompt）而非修改模型参数。这意味着预训练模型保持不变，只有输入提示被修改以适应下游的任务。通过设计和优化一组提示，可以使预训练模型执行特定任务。

prompt-tuning和传统的fine-tuning的主要区别在于预训练模型被修改的程度。fine-tuning修改模型的权重，而提示调整只修改模型的输入。因此，prompt-tuning调整比精调的计算成本低，需要的资源和训练时间也更少。此外，prompt-tuning比精调更灵活，因为它允许创建特定任务的提示，可以适应各种任务。

一切还是从BERT说起，Google提出BERT模型的时候，一个最大的贡献是使用了Masked Language Model（MLM），即随机掩盖输入序列的一个token，然后利用相邻的tokens预测这个token是什么，这样模型可以学会更好地理解上下文。

.. code:: json

    {
        "Input": "The man want to the [MASK], He bought a [MASK] of milk.",
        "Label": "[MASK]1 = store, [MASK]2 = gallon"
    }

BERT这种训练方式让模型在文本生成方面有很强的能力，因此，大家发现有时候不一定需要做fine-tuning即可让模型帮我们解决感兴趣的任务。只要我们把希望输出的部分删除掉，然后尽量构造与该输出有关的其它tokens即可。这就是prompt-tuning的一种想法！

与输出相关的tokens组成的上下文信息即可理解为是一个prompt。Prompt通常是一种短文本字符串，用于指导语言模型生成响应。Prompt提供上下文和任务相关信息，以帮助模型更好地理解要求，并生成正确的输出。例如，在问答任务中，prompt可能包含问题或话题的描述，以帮助模型生成正确的答案。Prompt通常是人类设计的，以帮助模型更好地理解特定任务或领域。

简单总结就是说Prompt就是利用语言模型的生成能力帮我们完成任务。而Prompt-tuning的目的就是设计更加精巧的prompt，然后让模型输出我们想要的内容。


Instruction-Tuning
--------------------------------------------------------------------------------

Instruction通常是一种更详细的文本，用于指导模型执行特定操作或完成任务。Instruction可以是计算机程序或脚本，也可以是人类编写的指导性文本。Instruction的目的是告诉模型如何处理数据或执行某个操作，而不是简单地提供上下文或任务相关信息。

因此，Prompt和Instruction都是用于指导模型生成输出的文本，但它们的目的和使用方式是不同的。Prompt更多地用于帮助模型理解任务和上下文，而Instruction则更多地用于指导模型执行具体操作或完成任务。

Instruction-Tuning这种方法Google和OpenAI几乎都同时使用了。

Google Research在2021年的论文《Finetuned Language Models Are Zero-Shot Learners》中提出了instruction-tuning。Google认为instruction-tuning是一种简单的方法来提高语言模型的zero-shot学习能力。

Instruction可以提供更直接的任务指导，以帮助模型执行任务。对于问答任务，Instruction可以提供具体的指令，例如“请回答下列问题：谁是美国第一位总统？”，并将文本段落作为输入提供给模型。

以InstructGPT为例，其基本流程如下：

1. 准备自然语言指令集：针对特定任务，准备一组自然语言指令，描述任务类型和任务目标，例如情感分类任务的指令可以是“该文本的情感是正面的还是负面的？”。
#. 准备训练数据集：针对特定任务，准备一个标记化的数据集，其中每个数据样本都包含输入文本和标签，例如情感分类任务的标签可以是“正面”或“负面”。
#. 将自然语言指令和数据集转换为模型输入：将自然语言指令和数据集转换为模型输入，例如对于情感分类任务，将自然语言指令和文本拼接作为输入，例如：“该文本的情感是正面的还是负面的？这家餐厅的食物很好吃。”
#. 在指令上进行微调：在指令上进行微调，以适应特定任务的需求，提高模型在任务上的性能。

这样的方式训练了出来的模型可以让模型更好地识别输入的意图，同时也在zero-shot中表现更好！

而Instruction-tuning的主要思想就是在输入阶段对指令做调整以其适合更好地模型输出！

Chain-of-Thought
--------------------------------------------------------------------------------

Chain-of-thought 是一种处理复杂问题或执行多步骤任务的技巧，通常用于大型预训练语言模型中。这种方法允许模型在多个步骤中生成连贯的回答，从而更好地解决问题或完成任务。

在 chain-of-thought 方法中，模型的输出被视为一个序列，每个部分都是一个独立的“思考链”或步骤。模型通过将先前的输出作为后续输入的一部分来迭代地生成这些部分，这样可以让模型在一定程度上模拟人类解决问题的过程。

Chain-of-thought训练中，将数据集中的输入分解为一系列任务是非常关键的一步。一般来说，这个过程需要根据特定的任务和数据集来进行定制。以下是一些通用的方法：
1. 首先，需要定义一个目标任务，即要求模型完成的最终任务。例如，如果目标任务是自然语言生成，那么数据集中的输入可能是一句话或一个段落，模型需要将其转化为自然语言响应。
#. 然后，需要将目标任务分解为一系列子任务。这些子任务应该是相互关联的，每个子任务的输出都可以作为下一个子任务的输入。例如，在自然语言生成任务中，可以将其分解为理解输入的语义、确定输出的语法结构、生成文本等子任务。
#. 每个子任务的输入和输出都需要定义。例如，在自然语言生成任务中，输入可能是一组与上下文相关的单词，输出可能是下一个单词或整个句子。
#. 每个子任务都需要为其定义一个训练目标和相应的损失函数。这些目标和损失函数应该与任务相关，并帮助模型学习与该任务相关的知识。
#. 最后，需要将所有子任务组合起来，构建一个完整的模型。每个子任务的输出都将成为下一个子任务的输入，直到完成目标任务。

需要注意的是，如何分解数据集中的输入取决于特定的任务和数据集。一个好的分解方案应该具有适当的层次结构，使得模型能够在学习过程中逐步掌握更加复杂的任务。在实际应用中，可能需要进行多次尝试和调整，才能找到最优的分解方案。

尽管 chain-of-thought 方法在处理一些复杂问题时可能有所帮助，但它并非万能的。有时，模型可能无法生成正确的答案，或者在多次迭代中陷入死循环。

总之，chain-of-thought 是一种有效的技巧，可以帮助大型预训练语言模型在多步骤任务和复杂问题中生成连贯的输出。然而，在实际应用中，可能需要结合其他技巧来克服其局限性，以实现更好的性能。

参考资料
--------------------------------------------------------------------------------

1. `caling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning <https://arxiv.org/abs/2303.15647>`_
#. `State-of-the-art Parameter-Efficient Fine-Tuning (PEFT) methods <https://github.com/huggingface/peft>`_
